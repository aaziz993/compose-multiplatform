config:
  imports:
    - io.ktor.server.websocket.WebSockets
    - io.ktor.websocket.WebSocketDeflateExtension
    - io.ktor.serialization.kotlinx.KotlinxWebsocketSerializationConverter
    - io.ktor.server.websocket.webSocket
    - io.ktor.websocket.Frame
    - io.ktor.websocket.readText
    - io.ktor.websocket.send
    - kotlinx.coroutines.channels.ClosedReceiveChannelException
    - kotlinx.coroutines.channels.consumeEach
    - kotlinx.coroutines.flow.MutableSharedFlow
    - kotlinx.coroutines.flow.asSharedFlow
    - kotlinx.coroutines.launch
script:
  - module: |
      {
        install(WebSockets) {
          contentConverter = KotlinxWebsocketSerializationConverter(Json)
          pingPeriodMillis= 15000
          timeoutMillis = 15000
          maxFrameSize = Long.MAX_VALUE
          masking = false

          extensions {
            install(WebSocketDeflateExtension) {
                /**
                 * Compression level to use for [java.util.zip.Deflater].
                 */
                compressionLevel = Deflater.DEFAULT_COMPRESSION

                /**
                 * Prevent compressing small outgoing frames.
                 */
                compressIfBiggerThan(bytes = 4 * 1024)
            }
          }
        }

        routing {
          val messageResponseFlow = MutableSharedFlow<String>()
          val sharedFlow = messageResponseFlow.asSharedFlow()
          webSocket("/ws") {
            send("You are connected to WebSocket!")

            val job = launch { sharedFlow.collect(::send) }

            runCatching {
                incoming.consumeEach { frame ->
                    if (frame is Frame.Text) messageResponseFlow.emit(frame.readText())
                }
            }.onFailure { exception ->
                println("WebSocket exception: ${exception.localizedMessage}")
            }.also {
                job.cancel()
            }
          }
        }
      }

#  page:
#    - enable: true
#      uri:
#      wsURI:
